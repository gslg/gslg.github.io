---
title: Redis 持久化
author: gslg
tags:
  - redis
  - cache
categories:
  - redis
date: 2019-07-03 21:57:00
---
## Redis持久化
这里主要总结Redis官方文档中关于Redis持久化的一些描述  
*Redis*提供了不同的持久性选项:
 - **RDB**: 以指定的时间间隔执行数据集的时间点快照来进行持久化
 - **AOF**: AOF持久化会记录服务器接收的每个写入操作，并在服务器启动时再次重放，从而重建原始的数据集。AOF文件使用与Redis协议本身相同的格式，以仅追加(`append-only`)的方式来记录操作命令。 当AOF文件变得太大时，Redis会在背后重写日志。AOF持久化类似于很多数据库的`WAL`日志.
 - 如果你只需要在服务运行的时候持有数据，那么可以禁用持久化功能
 - 可以将`RDB`和`AOF`两种方式结合起来。在这种情况下,当redis重启的时候，`AOF`文件将用来重建原始的数据集，因为`AOF`保证是最完整的.
<!--more-->
### RDB优点
 - RDB是Redis数据的一个非常紧凑的单文件时间点表示，非常适合备份。例如，你可能希望在最近24小时内每小时归档一次RDB文件，并在30天内每天保存一次RDB快照。这样即使在发生灾难时也可以轻松恢复数据集的不同版本。
 - RDB对于灾难恢复非常好，因为单个压缩文件可以传输到很远的数据中心，或者存放到`Amazon S3`上（可能是加密的）。
 - RDB最大限度地提高了Redis的性能，因为Redis父进程为持久化唯一做的工作就是分配一个将完成所有其余工作的子进程。父实例永远不会执行磁盘I/O或类似操作。
 - 与AOF相比,RDB在大的数据集时Redis重启更快  
 
### RDB缺点 
 - 如果需要在Redis突然停止(断电)时将数据丢失的可能性将至最低，RDB不能满足需求.虽然可以配置创建RDB的不同保存点（例如，在对数据集进行至少每五分钟和100次写入之后创建RDB文件）,但是，通常每五分钟或更长时间创建一个RDB快照，因此如果Redis因任何原因停止工作而没有正确关闭，这样就会丢失这段时间内最新产生的数据。
 - RDB经常需要`fork()`才能使用子进程持久存储在磁盘上。如果数据集很大,`fork()`可能会非常耗时。如果数据集很大并且CPU性能不佳,可能会导致`Redis`停止服务客户端几毫秒甚至一秒钟。虽然AOF也需要`fork()`,但可以调整重写日志的频率而不需要对持久性进行任何权衡(因为AOF会记录所有的写请求,基本不会丢失数据，Redis挂掉后重启时从AOF文件中重建数据即可。但是如果调整创建RDB快照的频率的话,需要权衡数据丢失的概率和性能，鱼与熊掌不可兼得啊)
 
### AOF优点
 - 使用AOF Redis更具有持久性：可以使用不同的`fsync`策略：
  1. 完全不执行fsync
  2. 每秒执行fsync
  3. 每次查询时执行fsync。  
  
  使用fsync的默认策略，每秒写入性能仍然很好(使用后台线程执行fsync，并且当没有fsync正在执行时，主线程将努力执行写入)但是只会丢失一秒的写入  
  
 - AOF日志是仅追加日志(`append-only`)，因此没有磁盘寻址，在突然断电时也没有损坏问题。即使由于某种原因（磁盘已满或其他原因）日志在命令写到一半时停止，`redis-check-aof`工具也能够轻松修复它。
 - 当AOF日志变得太大时，`Redis`可以在后台自动重写它。重写操作是绝对安全的，因为当`Redis`继续追加到旧文件时，将使用创建当前数据集所需的最小操作集生成一个完全新的文件，一旦第二个文件准备就绪，`Redis`将切换这两个文件并开始追加到新文件。
 - AOF以易于理解和分析的格式，一个接一个地记录所有操作日志。可以轻松导出AOF文件，例如，即使因为某个错误原因使用`FLUSHALL`命令清除了所有缓存数据，如果在此期间没有执行日志重写，你仍然可以恢复数据集:只需停止服务器、删除`AOF`日志中最新的命令(也就是`FLUSHALL`命令)，然后重新启动redis。
 
### AOF缺点
 - 相同数据集下,AOF文件通常大于同等效果的RDB文件
 - 根据确切的`fsync`策略，AOF可能比RDB慢。一般来说，`fsync`设置为每秒性能仍然非常高，并且在`fsync`禁用的情况下，即使在高负载下也应该与RDB一样快。尽管如此，RDB仍然能够提供关于最大延迟的更多保证，即使在写负载很大的情况下也是如此。
 - 在过去，遇到了极少特定命令中的罕见错误（例如，有一个涉及阻塞命令，如`BRPOPLPUSH`）导致生成的AOF在重新加载时不会重现完全相同的数据集。这个错误很少见，我们在测试套件中进行测试，自动创建随机复杂数据集并重新加载它们以检查一切正常，但RDB持久性几乎不可能出现这种错误。为了更清楚地说明这一点：`Redis AOF`以增量方式更新现有状态，就像`mysql`或`mongodb`那样，而`RDB`快照会一次又一次地从头创建所有内容，这在概念上更为健壮。但是，
  1. 应该注意的是，每次通过Redis重写AOF时，都会从数据集中包含的实际数据开始从头开始重新创建，与始终追加的AOF文件相比，可以更好地抵抗错误（或者重写一个旧的AOF而不是读取内存中的数据）。
  2. 我们从未收到用户提供的关于在实际使用中检测到的AOF损坏的单一报告。  
  
### RDB和AOF选择
一般来说，如果希望达到与`PostgreSQL`提供的数据安全性相当的安全性程度，则应使用两种持久性方法。  

如果你非常关心你的数据，但是在发生灾难的情况下允许有几分钟的数据丢失，那么可以单独使用RDB。  

有许多用户单独使用`AOF`,我们并不鼓励这么做,因为有一个不定期的RDB快照对于数据库备份、快速重启、以及如果AOF引擎出现错误时是一个非常好的选择.  

基于上面这些原因，可能在长期计划中会统一`AOF`和`RDB`持久化模型.

### 快照
Redis默认将数据集的快照保存在硬盘上的`dump.rdb`文件中.如果数据集中至少有`M`个键更改，可以配置redis每隔`N`秒保存一次数据集，或者可以手动的调用**SAVE**或**BGSAVE**命令。

例如，如果至少更改了1000个键，此配置将使redis每60秒自动将数据集转储到磁盘：
```
save 60 1000
```
这就是快照策略.

### 快照工作原理 

当Redis需要将数据集转储到磁盘时,会做以下事情:
-  `Redis`进行[`forks`](http://linux.die.net/man/2/fork).这样就有了一个子进程和一个父进程
- 子进程开始将数据集写入到一个临时的`RDB`文件
- 当子进程完成写入新的`RDB`文件时，会用这个新的替换旧的

这样使得Redis从`copy-on-write`语义中受益.

### Append-only 文件
快照并不特别持久化.如果运行Redis的机器意外停止了,断电或者意外使用`kill -9`杀掉了实例，那么Redis中最近写的数据就可能丢失.虽然这对一些应用来说并不是问题，但是对于一些需要完全持久化的应用来说，redis可能不是一个好的选择.  

对Redis来说,`Append-only`是一个可供选择的，完全持久化的策略.这个特性是Redis 1.1版本添加的,可以打开以下配置开启`AOF`：
```
appendonly yes
```
这之后，Redis每接收到一个会改变数据的命令就会把该命令追加记录到AOF文件中，当重启Redis时，会重放AOF文件来重建之前的状态.

### 日志重写

正如你想的那样，AOF文件会随着写操作执行的越来越多变得越来越大。例如，如果你对一个计数器进行递增100次的操作,在Redis中最后只会有一个Key以及它对应的递增结果值存在，但是在AOF文件中却会有100条递增操作的记录.其中99条对于重建当前状态是没有意义的.  

因此Redis有一个有趣的特性:它可以在后台重写AOF文件而不需要中断对连接客户端的服务。当你发出**BGREWRITEAOF**命令时，Redis将写入重建内存中当前数据集所需的最短命令序列到一个新的AOF文件中.如果你使用Redis 2.2版本的AOF，那么需要手动时不时的运行**BGREWRITEAOF**命令，Redis2.4版本之后会自动触发重写.

### Append-only文件的持久化能力

 你可以配置Redis在磁盘上同步数据的次数.一般有三种选择:
  - **始终同步(`appendfsync always`)**：每次将新的命令添加到AOF时就进行[`fsync`](http://linux.die.net/man/2/fsync),这样会非常慢但是非常安全
  - **每秒钟同步**: 每秒钟进行同步速度足够快(和快照方式差不多),在发生灾难时可能丢失1秒钟的数据.
  - **不同步**: 永远不进行同步到磁盘，只将数据放在操作系统的内存中。是更快但是更不安全的方法。通常情况下，如果使用这种配置，Linux会每隔30秒刷新一次数据，但这取决于内核的精确调整。  
  
  建议每秒钟进行`fsync`操作，这也是默认的策略.这样即快速也足够安全.`always`策略在实践中非常缓慢，但它支持组提交，因此如果存在多个并行写入，`Redis`会尝试执行单个`fsync`操作。

### AOF文件被截断情况处理
有可能服务器在写入AOF文件时崩溃了，或者存储AOF文件的卷空间满了,发生这种情况时，AOF仍然包含了数据集在给定时间点版本的一致数据（使用默认的`AOF fsync`策略时，该数据集的时间点版本可能最长为一秒钟），但AOF中的最后一个命令可能会被截断(也就是正在写入命令时服务器崩溃了或者磁盘满了,该命令只写了一半的情况)。最新主要版本的Redis无论如何都可以加载该AOF，只需丢弃文件中最后一个格式不正确的命令即可。在这种情况下，服务器将发出如下日志：
```
* Reading RDB preamble from AOF file...
* Reading the remaining AOF tail...
# !!! Warning: short read while loading the AOF file !!!
# !!! Truncating the AOF at offset 439 !!!
# AOF loaded anyway because aof-load-truncated is enabled
```
当然如果有需要的话,你也可以更改这个默认配置，使得Redis在这种情况下立即停止重启,Redis的默认配置是为了即使最后一个命令不正确，也可以忽略它来保证重启后立即可用.  

老版本的`Redis`可能不会自动恢复,可以采用以下步骤:  
 - 复制备份AOF文件
 - 在Redis附带的`redis-check-aof`工具修复原始文件:
 	```
    $ redis-check-aof --fix
   ```
 - 可以使用`diff -u`来检查两个文件的不同之处
 - 使用修复后的AOF文件重启Redis
  
### AOF文件损坏情况处理 
如果AOF文件不只是被截断，而是被中间的无效字节序列损坏，那么事情就更复杂了。Redis将在启动时报告并中止：
```
* Reading the remaining AOF tail...
# Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>
```
最好的做法是运行`redis-check-aof`程序，开始不要使用`--fix`选项，先找到问题所在，跳到文件中给定的偏移量，查看是否可以手动修复文件：`AOF`使用与`Redis`协议相同的格式，并且很容易手动修复。此外，可以用`redis-check-aof`为我们修复该文件，但在这种情况下，从无效部分到文件结尾的所有AOF部分可能会被丢弃，如果损坏恰好发生在文件的初始部分，则会导致大量数据丢失。  

### AOF日志重写工作原理
日志重写使用了和快照一样的`copy-on-write`原理:  
- `Redis forks`,这样就有一个子进程和一个父进程
- 子进程开始在临时文件写入新的AOF
- 父进程将所有新更改累积到内存缓冲区中（但同时它也将新更改写入旧的仅追加文件中，因此如果重写失败，也是安全的）。
- 当子进程重写完成后，父进程会收到一个信号，并在子进程生成的文件末尾附加内存缓冲区(也就是把上一步累积的新的更改追加到子进程新写的AOF文件中)。
- Redis自动从旧的AOF切换至新的AOF文件

  
## 引用
- [Redis Persistence](https://redis.io/topics/persistence)